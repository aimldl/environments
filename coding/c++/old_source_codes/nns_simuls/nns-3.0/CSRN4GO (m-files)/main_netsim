#!/bin/bash
# main_netsim
#
# main_netsim is a utility program to automate netsim simulations with different simulation parameters.
# The purpose is to save the labor of baby-sitting the entire process of simulations.
# main_netsim will take care of a multiple-number of simulations and postprocessing the simulation outputs.
# Therefore, the user can run main_netsim, take a break, and get an email when the simulation is over.
# 
# The functionalities include:
#    (1) running a multiple simulation with different simulation settings at a single run of main_netsim
#    (2) postprocessing the simulation outputs in the single run
#    (3) optionally mailing the status/error report of the run
#
#         (input)           !--------!                (output)
#  simulation settings ---> ! netsim ! ---> postprocessed simulation results + email (opt)
#                           !--------!
#
# A suggested way of using main_netsim is to consider main_netsim as the main interface to control the simulations.
# The simulation settings fed to main_netsim is suggested to store in another bash script in directory main_files. 
# For example, create a bash script run_video_usr_20to50.
#
#	#!/bin/bash
#	# run_video_usr_20to50
# 
#	main_netsim -u 20:5:50 -m 2
#
# And run the script run_video_usr_20to50. 
#
#       $ ./run_video_usr_20to50
#
# In this way, the structure of main_netsim remains the same while the simulation parameters can be stored.
#
# Directory structure
#     \ - archive           archive of previous simulation results
#	|
#       - bin               executables are stored
#	|
#	- main_scripts      main scripts to run simulations are stored
#	|
#	- postproc_results  postprocessed results are collected here for convenience
#	|
#	- simul_results	    simulation and postprocessed results are stored
#	|
#	- simul_templates   templates to run simulations
#	|
#   	- utility           utility scripts
#
# Type `./main_netsim -h` to see the usage.
#
# Last updated: Dec.20, 2007 (Thu)
# First written: Sep.27, 2007 (Thu)
#
# Tae-Hyung D. Kim

##################################################################################
#   			Options and Configuration				 #
##################################################################################

# *** Under construction
#####################################
#        Options in cfg file	    #
#####################################
# Some options in the netsim config file (*.cfg) can be changed here!
SLOTS_PER_SECOND='1500';
CHIPS_PER_SECOND='3840000';
RNG_SEED='7';
RUN_TIME_IN_SEC='100';
WARMUP_PERIOD_IN_SEC='0.1';
NB_DROPS='1';
DROP_USERS_UNIFORMLY='1';
CELL_RADIUS_M='1620';
NB_PER_SECTOR='28';

# TRAFFIC SOURCE VARIABLES
# To use a full_buffer, make sure the logical CH matches the transport CH.
# For example, 
# W_TrCh_vector = {
#	...
#		("TrCh_3", {("LogCh_3", 1, 0, "LL_1")}) #FULL_BUFFER Source
#		  }
# W_Mobile_Type_vector = {	#nb per sector
#				...
#                         (FULL_BUFFER, 3,"LogCh_3", "HS_PHY_BE", {W_HS_DSCH},)
#
#			 }
# TrCh_3 in W_TrCh_vector should be mapped to LogCh_3.
# In addition, the use of LogCh_3 should be specified in W_Mobile_Type_vector.
# The first element is changed to FULL_BUFFER, instead of VIDEO.
#

MAX_PC_PENDING_DATA_B='10000000';
PKT_CALL_SDU_SIZE_BITS='320';
FULL_BUFFER_PKT_INTERARRIVAL_SEC='0.02';
#PKT_CALL_SDU_SIZE_BITS='12000';
#FULL_BUFFER_PKT_INTERARRIVAL_SEC='0.01';
# *** Under construction

# *** Under construction
#####################################
#    Options for VideoConfigFile    #
#####################################
# Options for video decoding are defined in VideoConfigFile1.txt and VideoConfigFile2.txt.
# The only difference between the two text files is the comments.
# I don't know why, but the file structure is kept at this moment.

# INPUT_FORMAT, SQCIF: 1, QCIF: 2, CIF: 3, 4_CIF: 4, 16_CIF: 5, CUSTOM: 6
INPUT_FORMAT=2;
INPUT_FILE_NAME='foreman_qcif.yuv';
OUTPUT_FILE_NAME='bitstream.rtp';
BIT_RATE='64000';
FRAME_RATE='10';
FRAME_WIDTH_IN_PIXELS=176;
FRAME_HEIGHT_IN_PIXELS=144;
FEEDBACK_TIME_CONSTANT_IN_MSEC=200;
# *** Under construction

#####################################
#    Options for AVBRConfigFile    #
#####################################
AVBR_TRAFFIC_GEN_INTERVAL_MS=20.0;
AVBR_TRAFFIC_GEN_RATE_BPS=8000.0;
AVBR_RATE_UPPER_BOUND_BPS=15000.0;
AVBR_RATE_TARGET_BPS=13000.0;
AVBR_RATE_LOWER_BOUND_BPS=6000.0;
AVBR_DELAY_BOUND_MS=200.0;
AVBR_ALPHA=1.0;
AVBR_BETA=0.9;
AVBR_LAMBDA=5.0;
AVBR_STEP_2REDUCE_BYTES=300;
AVBR_R_MAX_BPS=20000;

#####################################
# Default options and configuration #
#####################################
# PLEASE DO NOT CHANGE THESE VALUES!
# If you want, change the options and configuration in "Overwrite Options Here" below .
OPT_MODE=0;
OPT_RUN_NETSIM=0;
OPT_LOOP=0;
OPT_POSTPROC=0;
OPT_PP_COLLECT=0;	# Collect data into a single directory for PP (Post-Process).
OPT_EMAIL=0;
OPT_BSUB=0;
OPT_DONT_RUN=0;
OPT_USE_OLD_NETSIM=0;
OPT_MC_SIMULS=0;
OPT_NEW=0;
OPT_DLY_BOUND=0;

OPT_TRAFFIC_TYPE="video";
OPT_SCENARIO="u"; 
#OPT_SCENARIO="fb";

# Counter for MC (Monte Carlo) simulations
CNTR_MC_MAX=10;

# Configure the number of users per sector to simulate
CFG_USER_PER_SECTOR_FROM=24;
CFG_USER_PER_SECTOR_INCR=4;
CFG_USER_PER_SECTOR_TO=52;

# Configure the delay bound in ms.
CFG_DELAY_BOUND_MS_FROM=0;
CFG_DELAY_BOUND_MS_INCR=0;
CFG_DELAY_BOUND_MS_TO=0;

# PLEASE DO NOT CHANGE THESE VALUES!

##################################################################################
#                                Procedures                                      #
##################################################################################
# *** Under construction
extr_netsim_configs () {
   # Extract some useful information from the netsim output file.
   
   local file_input=$1;
   local dir_output=$2;
   local file_name=${file_input%.*};
   echo "$file_name";

   cat $file_input | awk ' BEGIN {
   	file_awk_input=ARGV[1]; delete ARGV[1];
	dir_awk_output=ARGV[2]; delete ARGV[2];	
    	file_awk_output=dir_awk_output"/"file_awk_input".cfg";
   }{   
   	if ( $1 =="run_time_in_sec" \
	  || $1 =="warmup_period_in_sec" \
	  || $1 =="slots_per_second" \
	  || $1 =="chips_per_second" \
	  || $1 =="num_BSs" \
	  || $1 =="sector_per_BS" \
	  || $1 =="cell_radium_m" \
	  || $1 =="HSDPA_only" \
	  || $1 =="logNormalShadow_dB" \
	  || $1 =="neighboring_cell_interference" \
	  ) {
	   printf("%s\t%d\n", $1, $3) > file_awk_output;
	}
	
   	if ( $1 ~ "header_size=" \
	  || $1 ~ "PDU size=" \
	  ) {
	   split($1, tmp_column,"=");
	   printf("%s\t%d\n", tmp_column[1], tmp_column[2]) > file_awk_output;
	   
	}	
   }' $file_name $dir_output;
};

# A procedure show_usage
show_usage_main_netsim () {
echo "main_netsim is a utility program to automate netsim simulations. version 1.4

Usage: main_netsim [option]
   main_netsim [-m OPT_MODE] [-t OPT_TRAFFIC_TYPE] [-u CFG_USER_PER_SECTOR_FROM:CFG_USER_PER_SECTOR_INCR:CFG_USER_PER_SECTOR_TO]
Shell options:
   -h   Help. Type \`main_netsim -h\` for help.
   -b   Use bsub to run simulations. 
        bsub is a unix command to submit a job to the Hyperkeck Linux servers at Qualcomm.
	This option adds the prefix 'bsub -q priority' to each running command(s).
	Note this option disables the postprocessing. 
	That is, OPT_POSTPROC is forced to zero (OPT_POSTPROC=0).
	Even if the mode is set to use postprocessing, the -b option disables the postprocessing.
	In other words, the -b option is stronger than the -m option.
   -c   Collect the post-processed simulation results into directory postproc_results
        The options turned on are:
          OPT_PP_COLLECT=1;
          OPT_RUN_NETSIM=0;
          OPT_LOOP=1;
	  OPT_MC_SIMULS=1;
          OPT_POSTPROC=0;
   
   -d   Show the dummy commands.
        This option disables the execution of the commands.
	Therefore, one can see what commands will be run without waiting till the end of all the
	simulations.
	This option is useful BEFORE actually running the simulations. 
	Cation: Do not use this option to run simulations.
	        Use this just to check what commands will be run.
   -e   Email notice on the simulation status
        The option for the email notice is turned on if this option is used. That is,
           OPT_EMAIL=1;
   -i   Set the number of iterations for the MC (Monte Carlo) approach.
        In other words, the counter CNTR_MC_MAX will be stored.	
        Setting the number of iterations assumes that MC simulations will be performed.
	Therefore, OPT_MC_SIMULS is set to 1 (OPT_MC_SIMULS=1).
   -l   Set the delay bound in ms (OPT_DLY_BOUND=1). L stands for latency.
        Why L? Option b and d are already taken.
	The current implementation is to take a single delay bound value.
	The value following the -l option is stored in variable CFG_DELAY_BOUND_MS,
	and the delay bound in the config file is changed to this value.
	
	Later on, it should follow the following format.
        \"from:increment:to\" delimited by colon \":\". 
	For example, "-l 100:200:700" are internally mapped to:
           CFG_DELAY_BOUND_MS_FROM=100; CFG_DELAY_BOUND_MS_INCR=200; CFG_DELAY_BOUND_MS_TO=700;  
   -m   Mode of running, expecting an integer number to be stored in OPT_MODE.
         value    Mode       Run?  Loop Postprocessing                   Comment
           -1 Postprocessing  No   Yes       Yes         Skip simulations. Only postprocess the simulation results.
            0     manual      No    No        No         Turn off all the options.Typically used to test main_netsim. 
            1 single run+p   Yes    No       Yes         Run a simulation and postprocess the simulation results. 
            2 single run-p   Yes    No        No         Run a simulation, but skip the postprocessing. 
            3 multi-runs+p   Yes   Yes       Yes         Multiple runs with different simulation settings+postprocessing. 
            4 multi-runs-p   Yes   Yes        No         Multiple runs with different simulation settings; skip postprocessing. 
            5 MonteCarlo+p   Yes   Yes       Yes         Monte Carlo Simulations (+Multiple runs) +postprocessing. Mode3+MC
            6 MonteCarlo-p   Yes   Yes        No         Monte Carlo Simulations (+Multiple runs) -postprocessing. Mode4+MC
	Note: -m 4 -i 10 is identical to -m 6 while -m 3 -i 10 is equal to -m 5.
   -n   Use netsim.new instead of netsim to run the simulations.
        This option will set OPT_NEW to 1 (OPT_NEW=1).
   -o   Old netsim to run simulations.
        The option to use the old netsim is turned on if this option is used. That is,
          OPT_USE_OLD_NETSIM=1;	    
        Note that some parameters are NOT supported and may lead to segmenfation faults if the older version is used.
   -t   The Traffic type defined in Traffic_Source.{hxx, cxx}
           no_traffic, voice, full_buffer, control, upper_layer_data, upper_layer_data_rl, video, any, exp_voice, gv4_voice
	Currently, only full_buffer and video are tested.   
   -u   Configure the number of mobile users per sector to simulate.
        The format is \"from:increment:to\" delimited by colon \":\". 
	For example, "-u 24:4:52" are internally mapped to:
           CFG_USER_PER_SECTOR_FROM=24; CFG_USER_PER_SECTOR_INCR=4; CFG_USER_PER_SECTOR_TO=52;  
Default values for the options:
   -b OPT_BSUB=0; 
   -c OPT_PP_COLLECT=1;
      OPT_RUN_NETSIM=0;
      OPT_LOOP=1;
      OPT_MC_SIMULS=1;
      OPT_POSTPROC=0;   
   -d OPT_DONT_RUN=0;
   -e OPT_EMAIL=0;
   -i CNTR_MC_MAX=10; OPT_MC_SIMULS=0;
   -l OPT_DLY_BOUND=0;
   -n OPT_NEW=0;
   -m OPT_MODE=0;
   -o OPT_USE_OLD_NETSIM=0;
   -t OPT_TRAFFIC_TYPE=video;
   -u CFG_USER_PER_SECTOR_FROM=24; CFG_USER_PER_SECTOR_INCR=4; CFG_USER_PER_SECTOR_TO=52;
Examples:
	main_netsim -m 2 -t video -u 24:4:52 
	main_netsim -m 2 -t full_buffer -u 24:4:52 	
	main_netsim -u 24:4:52 -t video
	main_netsim -u 24:4:52 -t 	
	main_netsim -u 24:4:52 -m 2 -t video
	main_netsim -m 3 -t video
	main_netsim -m "-1" -u 24:4:52 -t video	
Cautions:
   The -u option specifies the number of users per sector, NOT the number of users per cell.	
   This script is designed for bash. It is suggested to run this script in bash.

For further information, refer to README. Report bugs at taehyung@qualcomm.com or tk424@umr.edu."
   exit 1;
}

change_template_next_line () {
   # Usage: change_template_next_line file_name string_to_match new_value
   #    Given the template file, new_value is overwritten if string_to_match
   #    matches the line. 
   
   # If the string matches the next line is changed.
   local file2change=$1;
   local string2match=$2;
   local new_value=$3;
   local file_tmp="${file2change}.tmp";
   
   cat $file2change | awk ' BEGIN {
      # Comand line input to awk
      file_awk_output=ARGV[1]; delete ARGV[1];
      expr2match=ARGV[2]; delete ARGV[2];
      value2change=ARGV[3]; delete ARGV[3];
      flag_found=0;
   } {
         if ( $1 == expr2match && flag_found==0 ) 
	 {
	    print > file_awk_output;
            flag_found=1;
	 } else if ( flag_found==1 )
	 {
	    printf("\t\t( %d, {\n",value2change) > file_awk_output;
            flag_found=0;
	 } else 
	 {
	    print > file_awk_output;
	 }
   } END {
      close(file_awk_output);                       # Explicitly close the opened file.
   }' $file_tmp $string2match $new_value;
   mv ${file_tmp} ${file2change};
}

# change_template_int, change_template_float, and change_template_string are
# identical except only one line. The different lines for each of the above functions are
# shown below.
# 
#     printf("%s = %d\n",expr2match, value2change)> file_awk_output;
#     printf("%s = %2.1f\n",expr2match, value2change)> file_awk_output;
#     printf("%s = %s\n",expr2match, value2change)> file_awk_output;
#
# As can be seen, the difference is the output format for value2change.
# The first line outputs in integer; the second in floating point; the last in string.

change_template_int () {
   # Usage: change_template_int file_name string_to_match new_value
   #    Given the template file, new_value is overwritten if string_to_match
   #    matches the line. 
   
   # Note that matching line and the line that changes the value are identical.
   local file2change=$1;
   local string2match=$2;
   local new_value=$3;
   local file_tmp=${file2change}'.tmp';
   
   cat $file2change | awk ' BEGIN {
      # Comand line input to awk
      file_awk_output=ARGV[1]; delete ARGV[1];
      expr2match=ARGV[2]; delete ARGV[2];
      value2change=ARGV[3]; delete ARGV[3];
   } {
         if ( $1 == expr2match ) 
	 {
	    printf("%s = %d\n",expr2match, value2change)> file_awk_output;
	 } else 
	 {
	    print> file_awk_output;
	 }
   } END {
      close(file_awk_output);                       # Explicitly close the opened file.
   }' $file_tmp $string2match $new_value;
   mv ${file_tmp} ${file2change};
}

change_template_float () {
   # Usage: change_template_float file_name string_to_match new_value
   #    Given the template file, new_value is overwritten if string_to_match
   #    matches the line. 
   
   # Note that matching line and the line that changes the value are identical.
   local file2change=$1;
   local string2match=$2;
   local new_value=$3;
   local file_tmp=${file2change}'.tmp';
   
   cat $file2change | awk ' BEGIN {
      # Comand line input to awk
      file_awk_output=ARGV[1]; delete ARGV[1];
      expr2match=ARGV[2]; delete ARGV[2];
      value2change=ARGV[3]; delete ARGV[3];
   } {
         if ( $1 == expr2match ) 
	 {
	    printf("%s = %2.1f\n",expr2match, value2change)> file_awk_output;
	 } else 
	 {
	    print> file_awk_output;
	 }
   } END {
      close(file_awk_output);                       # Explicitly close the opened file.
   }' $file_tmp $string2match $new_value;
   mv ${file_tmp} ${file2change};
}

change_template_string () {
   # Usage: change_template_string file_name string_to_match new_value
   #    Given the template file, new_value is overwritten if string_to_match
   #    matches the line. 
   
   # Note that matching line and the line that changes the value are identical.
   local file2change=$1;
   local string2match=$2;
   local new_value=$3;
   local file_tmp=${file2change}'.tmp';
   
   cat $file2change | awk ' BEGIN {
      # Comand line input to awk
      file_awk_output=ARGV[1]; delete ARGV[1];
      expr2match=ARGV[2]; delete ARGV[2];
      value2change=ARGV[3]; delete ARGV[3];
   } {
         if ( $1 == expr2match ) 
	 {
	    printf("%s = %s\n",expr2match, value2change)> file_awk_output;
	 } else 
	 {
	    print> file_awk_output;
	 }
   } END {
      close(file_awk_output);                       # Explicitly close the opened file.
   }' $file_tmp $string2match $new_value;
   mv ${file_tmp} ${file2change};
}


##################################################################################
#     Directory, files, and options changed from the command-line options        #
##################################################################################
# This part is central to automate the simulations.
# Given the command line options, appropriate changes are made in this part.
# If you want to change options and configuration, please do so in this part,
# NOT in the default options and configuration part. 

#####################################
#        Command line options       #
#####################################
MIN_NUM_OF_ARGS=1;
COMMAND_LINE_OPTS=":hbcdei:l:nm:ot:u:";

if [ $# -lt $MIN_NUM_OF_ARGS ];then
   show_usage_main_netsim;
   exit 1;
fi

while getopts $COMMAND_LINE_OPTS Option; do
   case $Option in
      h ) show_usage_main_netsim ;;
      b ) # Instead of running simulations on the current shell,
          # submit a job to the servers usinb the "bsub" command.
          OPT_BSUB=1;
	  echo " Warning: Note that this bsub option has not been implemented for postproc_netsim yet.";
	  ;;
      c ) # Use -m 0 (manual mode) to use this option.
          OPT_PP_COLLECT=1;      
          OPT_RUN_NETSIM=0;
          OPT_LOOP=1;
          OPT_POSTPROC=0;
	  ;;	  
      d ) # Show "D"ummy commands or "D"on't run.
          # Don't run the actual commands. Just show what commands will be run.
          OPT_DONT_RUN=1;
	  ;;	  
      e ) # Set up to send an email to notice the simulation status.
          OPT_EMAIL=1;
	  ;;
      i ) # Set the number of iterations for the MC (Monte Carlo) approach
          CNTR_MC_MAX=${OPTARG};
          OPT_MC_SIMULS=1;
	  ;;
      l ) # Set the delay bound. L stands for latency.
          # Why L? Option b and d are already taken.
	  
	  # The current implementation is to take a single delay bound value.
	  # Later on, it should follow the following format.
          # \"from:increment:to\" delimited by colon \":\". 
	  # For example, "-l 100:200:700" are internally mapped to:
          # CFG_DELAY_BOUND_MS_FROM=100; CFG_DELAY_BOUND_MS_INCR=200; CFG_DELAY_BOUND_MS_TO=700;  
	  
	  # TMP_12=${OPTARG%:*}; TMP_23=${OPTARG#*:};
	  # TMP_1=${TMP_12%:*}; TMP_2=${TMP_12#*:}; TMP_3=${TMP_23#*:};
	  # CFG_DELAY_BOUND_MS_FROM=${TMP_1};
	  # CFG_DELAY_BOUND_MS_INCR=${TMP_2};
	  # CFG_DELAY_BOUND_MS_TO=${TMP_3};
          OPT_DLY_BOUND=1;
	  CFG_DELAY_BOUND_MS=${OPTARG};
	  ;;
      n ) # Use netsim.new instead of netsim to run the simulations.
          OPT_NEW=1; 
	  ;;
	  
      m ) OPT_MODE=$OPTARG; 
#          echo "-m $OPT_MODE";
	  ;;
      o ) # Use the old netsim
          OPT_USE_OLD_NETSIM=1;
	  ;;
	  
      t ) OPT_TRAFFIC_TYPE=${OPTARG};
   	  OPT_SCENARIO=${OPT_TRAFFIC_TYPE}'_u';
#	  echo "OPT_TRAFFIC_TYPE=$OPT_TRAFFIC_TYPE";
#	  echo "OPT_SCENARIO=$OPT_SCENARIO";
      	  ;;
      u ) # Split the argument. The separator is colon ":"
	  TMP_12=${OPTARG%:*}; TMP_23=${OPTARG#*:};
	  TMP_1=${TMP_12%:*}; TMP_2=${TMP_12#*:}; TMP_3=${TMP_23#*:};

	  CFG_USER_PER_SECTOR_FROM=$TMP_1;
	  CFG_USER_PER_SECTOR_INCR=$TMP_2;
	  CFG_USER_PER_SECTOR_TO=$TMP_3;
#	  echo "   from=$CFG_USER_PER_SECTOR_FROM, incr= $CFG_USER_PER_SECTOR_INCR, to=$CFG_USER_PER_SECTOR_TO";
	  ;;	  
      * ) echo "This option is not supported.";
      	  echo "Type \`main_netsim -h\` for help." ;;
   esac
done
shift $(($OPTIND -1))

#####################################
#        Directory Structure        #
#####################################
DIR_ROOT=~+;						# Same as `pwd`
DIR_BIN="bin";
DIR_POSTPROC="postproc_results";
DIR_TEMPLATES="simul_templates";
DIR_RESULTS="simul_results";
DIR_SRC="source_codes";
DIR_UTIL="util_files";

# Set the path for the executables in directory bin.
export PATH="$PATH:$DIR_ROOT/$DIR_BIN"

# If the directory does not exist, create one.
if test ! -d $DIR_RESULTS; then
   echo "   Creating a directory $DIR_RESULTS";
   mkdir $DIR_RESULTS;
fi
if test ! -d $DIR_POSTPROC; then
   echo "   Creating a directory $DIR_POSTPROC";
   mkdir $DIR_POSTPROC;
fi

#####################################
#               Files               #
#####################################
NETSIM_EXE_NEW="netsim.new";
NETSIM_EXE_STABLE="netsim";
NETSIM_EXE_OLD="netsim.old";
NETSIM_EXE_NEW_DBG="netsim.dbg.new";
NETSIM_EXE_STABLE_DBG="netsim.dbg";
NETSIM_EXE_OLD_DBG="netsim.dbg.old";

if [ ${OPT_USE_OLD_NETSIM} -eq 1 ];then
   # In this case, the old netsim is used.
   NETSIM_EXE=${NETSIM_EXE_OLD};
else
   # The default setting is to use the new netsim.
   NETSIM_EXE=${NETSIM_EXE_STABLE};   
fi

#***
# The option for -o and -n should be combined together.
#***
if [ ${OPT_NEW} -eq 1 ];then
   NETSIM_EXE=${NETSIM_EXE_NEW};   
fi

FILE_NETSIM_CFG=$OPT_TRAFFIC_TYPE".cfg";                         # config file to netsim
FILE_POSTPROC_CFG=$OPT_TRAFFIC_TYPE".pcfg";                      # config file to postproc_netsim
FILE_DRC="HSDPA_16Q_336bit_2sl_-4.drc";
FILE_W_UL_CQI_STC="w_ul_cqi_stc.cfg";

# Before running simulations, the template files are copied to a newly created directory.
# Some parameters in the template files are modified to customize the simulation run.
TEMPLATE4NETSIM="${FILE_NETSIM_CFG}";
if [ $OPT_TRAFFIC_TYPE == "video" ];then
   TEMPLATE4VIDEO="${INPUT_FILE_NAME} ${FILE_DRC} VideoConfigFile1.txt VideoConfigFile2.txt";
   LIST_TEMPLATE_FILES="${TEMPLATE4NETSIM} ${TEMPLATE4VIDEO}";
elif [ $OPT_TRAFFIC_TYPE == "full_buffer" ];then
   LIST_TEMPLATE_FILES="${TEMPLATE4NETSIM} ${FILE_DRC} ${FILE_W_UL_CQI_STC}";
elif [ $OPT_TRAFFIC_TYPE == "avbr" ];then
   LIST_TEMPLATE_FILES="${TEMPLATE4NETSIM} ${FILE_DRC} ${FILE_W_UL_CQI_STC}";   
fi

#####################################
#    Options for the email notice   #
#####################################
TIME_START_SIMUL="";
TIME_END_SIMUL="";
TIME_START_POSTPROC="";
TIME_END_POSTPROC="";
MAIL_RECIPIENTS="taehyung@qualcomm.com";

#####################################
#    Options for the running mode   #
#####################################
# The running mode is a suggested way of using a group of options.
# The default options will be overwritten here.
# You can manually set the options by setting OPT_MODE=0 in "Overwrite Options Here" below.

# DO NOT CHANGE THESE LINES UNLESS YOU INTEND TO CHANGE THE WHOLE STRUCTURE.
if [ $OPT_MODE -eq -1 ];then    # Postprocessing only
   OPT_RUN_NETSIM=0;
   OPT_LOOP=1;
   OPT_POSTPROC=1;
   # OPT_MC_SIMULS is set to 0 by default.
   # If the -i option is used, OPT_MC_SIMULS is set to 1.
elif [ $OPT_MODE -eq 1 ];then    # Single run with postprocessing
   OPT_RUN_NETSIM=1;
   OPT_LOOP=0;   
   OPT_POSTPROC=1;
   OPT_MC_SIMULS=0;        
elif [ $OPT_MODE -eq 2 ];then    # Single run without postprocessing
   OPT_RUN_NETSIM=1;
   OPT_LOOP=0;
   OPT_POSTPROC=0;
   OPT_MC_SIMULS=0;        
elif [ $OPT_MODE -eq 3 ];then    # Multiple runs with postprocessing
   OPT_RUN_NETSIM=1;
   OPT_LOOP=1;
   OPT_POSTPROC=1;   
   OPT_MC_SIMULS=0;        
elif [ $OPT_MODE -eq 4 ];then    # Multiple runs without postprocessing
   OPT_RUN_NETSIM=1;
   OPT_LOOP=1;
   OPT_POSTPROC=0;
   OPT_MC_SIMULS=0;   
elif [ $OPT_MODE -eq 5 ];then    # Multiple runs with postprocessing (MC simulations)
   OPT_RUN_NETSIM=1;
   OPT_LOOP=1;
   OPT_POSTPROC=1;
   OPT_MC_SIMULS=1;
elif [ $OPT_MODE -eq 6 ];then    # Multiple runs without postprocessing (MC simulations)
   OPT_RUN_NETSIM=1;
   OPT_LOOP=1;
   OPT_POSTPROC=0;
   OPT_MC_SIMULS=1;
elif [ $OPT_MODE -lt -1 ] || [ $OPT_MODE -gt 6 ];then
   echo -e "\033[34mError: wrong value for OPT_MODE.\033[0m";
   show_usage_main_netsim;
   exit 1;
fi   
# DO NOT CHANGE THESE LINES UNLESS YOU INTEND TO CHANGE THE WHOLE STRUCTURE.

#####################################
#     Overwrite Options Here        #
#####################################
# The default values are specified in "Default options and configuration".
# You can overwrite the following values here if you want.
if [ $OPT_MODE -eq 0 ];then
   echo "";
OPT_RUN_NETSIM=0;
OPT_LOOP=1;
OPT_POSTPROC=0;
OPT_EMAIL=0;

#OPT_TRAFFIC_TYPE="video";
#OPT_SCENARIO="u"; 

# Configure the number of users per sector to simulate
#CFG_USER_PER_SECTOR_FROM=24;
#CFG_USER_PER_SECTOR_INCR=4;
#CFG_USER_PER_SECTOR_TO=52;
fi

#**** This part is temporal and needs to be changed.
if [ ${OPT_BSUB} -eq 1 ];then
   # OPT_BSUB override the mode.
   OPT_POSTPROC=0;
fi
#**** This part is temporal and needs to be changed.

##################################################################################
#   				Run Simulations				 	 #
##################################################################################
# If OPT_RUN_NETSIM is enabled, i.e. OPT_RUN_NETSIM=1, 
#    this part performs the following routine:
#
#    (1) Set up the simulation. 
#        (i) Create a directory to run a new simulation.
#       (ii) Copy the template files from directory simul_templates to the new directory.
#      (iii) Modify the template files to customize the simulation. 
#            For example, change the number of users per sector in the cfg file.
#    (2) Run the simulation. The command to run netsim is in essence
#
#        $ netsim cfg_file_name out_file_name > log_file_name
#
#    (3) Set up the next loop.
#        If a multiple run is enabled (OPT_LOOP=1), 
#           change the parameter index for looping and go to step (1);
#        otherwise, escape the loop and finish this part.
# 
# If OPT_RUN_NETSIM is disabled (OPT_RUN_NETSIM=0), this part is bypassed.

if [ $OPT_RUN_NETSIM -eq 1 ];then
   TIME_START_SIMUL=`date +"%X, %F";`;
   echo "   Start of the simulations: ${TIME_START_SIMUL}";
   #####################################
   # Step.1 Set up the simulation      #
   #####################################
   # If OPT_LOOP is turned on, make a loop; otherwise, "break" the loop for a single run.   
   if [ $OPT_LOOP -eq 1 ];then
      LOOPING_INDX=$CFG_USER_PER_SECTOR_FROM;
   else
      LOOPING_INDX=0;
   fi
   while [ $LOOPING_INDX -le $CFG_USER_PER_SECTOR_TO ];do   
      if [ $OPT_LOOP -eq 0 ];then   
         LOOPING_INDX="_single_run";
      fi
      
      if [ ${OPT_DLY_BOUND} -eq 1 ];then
         SCN_NAME=${OPT_SCENARIO}${LOOPING_INDX}"-"${CFG_DELAY_BOUND_MS};
      else
         SCN_NAME=${OPT_SCENARIO}${LOOPING_INDX};      
      fi
      
      echo "";      
      
      #####################################
      # Step 1.i Make a working directory #
      #####################################	
      cd $DIR_ROOT"/"$DIR_RESULTS;
      # If the directory does not exist, create one.
      if test ! -d ${SCN_NAME}; then
   	echo -e "      mkdir ${SCN_NAME};";
   	mkdir ${SCN_NAME};
      fi

##################################################################################      
      if [ ${OPT_MC_SIMULS} -eq 1 ];then
##################################################################################      
         CNTR_MC=${CNTR_MC_MAX};
	 
	 while [ ${CNTR_MC} -gt 0 ];do
            cd $DIR_ROOT"/"$DIR_RESULTS"/"${SCN_NAME};
            # If the directory does not exist, create one.
            if test ! -d ${CNTR_MC}; then
   	      echo -e "      mkdir ${CNTR_MC};";
   	      mkdir ${CNTR_MC};
            fi	 
	 
            DIR_2RUN=$DIR_ROOT"/"$DIR_RESULTS"/"${SCN_NAME}"/"${CNTR_MC};
      
            #####################################
            # Step 1.ii Copy the templates      #
            #####################################
            echo "      Copying template files for ${SCN_NAME}/${CNTR_MC}";
            cd $DIR_ROOT"/"$DIR_TEMPLATES; 
            cp $LIST_TEMPLATE_FILES $DIR_2RUN;

            #####################################
            # Step 1.iii Change the templates   #
            #####################################
            # Change the number of users in the template
            # This part is hard-coded for simplicity.
            cd $DIR_2RUN;
            echo "      Changing the template file for ${TEMPLATE4NETSIM}";            

            change_template_int ${TEMPLATE4NETSIM} "rng_seed" ${CNTR_MC};
            change_template_int ${TEMPLATE4NETSIM} "run_time_in_sec" ${RUN_TIME_IN_SEC};
            change_template_float ${TEMPLATE4NETSIM} "warmup_period_in_sec" ${WARMUP_PERIOD_IN_SEC};
            change_template_next_line ${TEMPLATE4NETSIM} "W_Mobile_Type_vector" ${LOOPING_INDX};

            if [ $OPT_TRAFFIC_TYPE == "avbr" ];then
               change_template_float ${TEMPLATE4NETSIM} "avbr_traffic_gen_interval_ms" ${AVBR_TRAFFIC_GEN_INTERVAL_MS};
               change_template_float ${TEMPLATE4NETSIM} "avbr_traffic_gen_rate_bps" ${AVBR_TRAFFIC_GEN_RATE_BPS};
               change_template_float ${TEMPLATE4NETSIM} "avbr_rate_upper_bound_bps" ${AVBR_RATE_UPPER_BOUND_BPS};
               change_template_float ${TEMPLATE4NETSIM} "avbr_rate_target_bps" ${AVBR_RATE_TARGET_BPS};
               change_template_float ${TEMPLATE4NETSIM} "avbr_rate_lower_bound_bps" ${AVBR_RATE_LOWER_BOUND_BPS};
	       
               if [ ${OPT_DLY_BOUND} -eq 1 ];then
	       # If the -l option is used, use the delay bound set by the command line argument.
                  change_template_float ${TEMPLATE4NETSIM} "avbr_delay_bound_ms" ${CFG_DELAY_BOUND_MS};
	       else
                  change_template_float ${TEMPLATE4NETSIM} "avbr_delay_bound_ms" ${AVBR_DELAY_BOUND_MS};	       
	       fi
               change_template_float ${TEMPLATE4NETSIM} "avbr_alpha" ${AVBR_ALPHA};
               change_template_float ${TEMPLATE4NETSIM} "avbr_beta" ${AVBR_BETA};
               change_template_float ${TEMPLATE4NETSIM} "avbr_lambda" ${AVBR_LAMBDA};
               change_template_int   ${TEMPLATE4NETSIM} "avbr_step_2reduce_bytes" ${AVBR_STEP_2REDUCE_BYTES};
               change_template_int   ${TEMPLATE4NETSIM} "avbr_R_max_bps" ${AVBR_R_MAX_BPS};
   	    fi

            #####################################
            # Step 2 Run the simulation         #
            #####################################
            echo "      cd $DIR_2RUN";
            cd $DIR_2RUN;                       # To make sure we are in the right directory!
            echo "      Running netsim... (Log file=${SCN_NAME}.nlog)";
            FILE_NETSIM_OUT=${SCN_NAME}'.nout'; # output file for netsim      
            FILE_NETSIM_LOG=${SCN_NAME}'.nlog'; # Log file for netsim

            RUN_CMD="${NETSIM_EXE} ${FILE_NETSIM_CFG} ${FILE_NETSIM_OUT}";      
            if [ ${OPT_BSUB} -eq 1 ]; then
               RUN_BSUB="bsub -q normal ${RUN_CMD}";	 
               echo "         ${RUN_BSUB}";
               echo "         The simulation log file will be included in the email from bsub.";
               if [ ${OPT_DONT_RUN} -eq 1 ];then
	          echo "         *********** Dummy command: netsim is not executed! ***********";
   	       else
                  eval ${RUN_BSUB};
	       fi
            else
               echo "         ${RUN_CMD}> ${FILE_NETSIM_LOG}";
	       if [ ${OPT_DONT_RUN} -eq 1 ];then
	          echo "         *********** Dummy command: netsim is not executed! ***********";
	       else
                  eval "${RUN_CMD} > ${FILE_NETSIM_LOG}";
	       fi
            MAIL_MESSAGE="${MAIL_MESSAGE}   ${RUN_CMD} for ${CNTR_MC}";
            fi
	    
	    let CNTR_MC=${CNTR_MC}-1;	    
	 done

##################################################################################
      else
##################################################################################      
         DIR_2RUN=$DIR_ROOT"/"$DIR_RESULTS"/"${SCN_NAME};
      
         #####################################
         # Step 1.ii Copy the templates      #
         #####################################	
         echo "      Copying template files for ${SCN_NAME}";
      
         cd $DIR_ROOT"/"$DIR_TEMPLATES; 
         cp $LIST_TEMPLATE_FILES $DIR_2RUN;

         #####################################
         # Step 1.iii Change the templates   #
         #####################################	
         # Change the number of users in the template
         # This part is hard-coded for simplicity.
         cd $DIR_2RUN;
         echo "      Changing the template file for ${TEMPLATE4NETSIM}";            
      
         change_template_int ${TEMPLATE4NETSIM} "run_time_in_sec" ${RUN_TIME_IN_SEC};
         change_template_float ${TEMPLATE4NETSIM} "warmup_period_in_sec" ${WARMUP_PERIOD_IN_SEC};      
         change_template_next_line ${TEMPLATE4NETSIM} "W_Mobile_Type_vector" ${LOOPING_INDX};
	 
         if [ $OPT_TRAFFIC_TYPE == "avbr" ];then
            change_template_float ${TEMPLATE4NETSIM} "avbr_traffic_gen_interval_ms" ${AVBR_TRAFFIC_GEN_INTERVAL_MS};
            change_template_float ${TEMPLATE4NETSIM} "avbr_traffic_gen_rate_bps" ${AVBR_TRAFFIC_GEN_RATE_BPS};
            change_template_float ${TEMPLATE4NETSIM} "avbr_rate_upper_bound_bps" ${AVBR_RATE_UPPER_BOUND_BPS};
            change_template_float ${TEMPLATE4NETSIM} "avbr_rate_target_bps" ${AVBR_RATE_TARGET_BPS};
            change_template_float ${TEMPLATE4NETSIM} "avbr_rate_lower_bound_bps" ${AVBR_RATE_LOWER_BOUND_BPS};
	    
	  CFG_DELAY_BOUND_MS_FROM=${TMP_1};
	  CFG_DELAY_BOUND_MS_INCR=${TMP_2};
	  CFG_DELAY_BOUND_MS_TO=${TMP_3};
            if [ ${OPT_DLY_BOUND} -eq 1 ];then	  
	       AVBR_DELAY_BOUND_MS=
	    fi
            change_template_float ${TEMPLATE4NETSIM} "avbr_delay_bound_ms" ${AVBR_DELAY_BOUND_MS};	    
            change_template_float ${TEMPLATE4NETSIM} "avbr_alpha" ${AVBR_ALPHA};
            change_template_float ${TEMPLATE4NETSIM} "avbr_beta" ${AVBR_BETA};
            change_template_float ${TEMPLATE4NETSIM} "avbr_lambda" ${AVBR_LAMBDA};
            change_template_int   ${TEMPLATE4NETSIM} "avbr_step_2reduce_bytes" ${AVBR_STEP_2REDUCE_BYTES};
            change_template_int   ${TEMPLATE4NETSIM} "avbr_R_max_bps" ${AVBR_R_MAX_BPS};
	 fi
      
         #####################################
         # Step 2 Run the simulation         #
         #####################################	
         echo "      cd $DIR_2RUN";
         cd $DIR_2RUN;                       # To make sure we are in the right directory!
         echo "      Running netsim... (Log file=${SCN_NAME}.nlog)";
         FILE_NETSIM_OUT=${SCN_NAME}'.nout'; # output file for netsim      
         FILE_NETSIM_LOG=${SCN_NAME}'.nlog'; # Log file for netsim

         RUN_CMD="${NETSIM_EXE} ${FILE_NETSIM_CFG} ${FILE_NETSIM_OUT}";      
         if [ ${OPT_BSUB} -eq 1 ]; then
            RUN_BSUB="bsub -q priority ${RUN_CMD}";	 
            echo "         ${RUN_BSUB}";
            echo "         The simulation log file will be included in the email from bsub.";
            if [ ${OPT_DONT_RUN} -eq 1 ];then
	          echo "         *********** Dummy command: netsim is not executed! ***********";
	    else
               eval ${RUN_BSUB};
	    fi
         else
            echo "         ${RUN_CMD}> ${FILE_NETSIM_LOG}";
	    if [ ${OPT_DONT_RUN} -eq 1 ];then
	          echo "         *********** Dummy command: netsim is not executed! ***********";
	    else
               eval "${RUN_CMD} > ${FILE_NETSIM_LOG}";
	    fi
         MAIL_MESSAGE="${MAIL_MESSAGE}   ${RUN_CMD}";
         fi
      # if [ ${OPT_MC_SIMULS} -eq 1 ];then 
##################################################################################      
      fi
##################################################################################
      
      # You may use "read" for debugging.
      # However, make sure "read" is commented out before running the simulations.
      # The simulation may stop for days unless you notice this. ;)
      # echo "read"; read;0
      
      #####################################
      # Step 3 Set up the next loop       #
      #####################################	
      if [ $OPT_LOOP -eq 0 ];then # Breaking out of the loop for a single run
         break;      
      fi
      # Increment the user index by CFG_USER_PER_SECTOR_INCR.
      let LOOPING_INDX=LOOPING_INDX+$CFG_USER_PER_SECTOR_INCR;
   done
   echo "";   
   TIME_END_SIMUL=`date +"%X, %F";`;
   echo "   End of the simulations: ${TIME_END_SIMUL}";   

# Comment this part out because sending two mails for a short simulation run is bugging.
#   if [ ${OPT_EMAIL} -eq 1 ];then
#      MAIL_MESSAGE="
#      TIME_START_SIMUL=${TIME_START_SIMUL}         
#      TIME_END_SIMUL=${TIME_END_SIMUL}";
#      MAIL_TITLE="Netsim. Simulation done.";   
#      echo "   Sending an email notice to ${MAIL_RECIPIENTS}";
#      echo ${MAIL_MESSAGE} | mail -s "${MAIL_TITLE}" ${MAIL_RECIPIENTS};
#   fi
# Comment this part out because sending two mails for a short simulation run is bugging.

fi


##################################################################################
#                      Postprocess the simulation results                        #
##################################################################################
# If OPT_POSTPROC is enabled, i.e. OPT_POSTPROC=1, 
#    this part performs the following routine:
#
#    (1) Setup to postprocess. 
#        (i) Set the directory to collect the postprocessed data (DIR_POSTPROC_RESULTS).
#            If DIR_POSTPROC_RESULTS exists, ask if the user wants to overwrite the
#               existing directory; otherwise, create a new directory.
#       (ii) Set up to postprocess the data in each individual directory.
#      (iii) Copy the template config file for postproc_netsim (*.pcfg).
#       (iv) Modify the template file to customize the postprocessing.

#    (2) Postprocess the data in the given directory. The command is in essence
#
#        $ postproc_netsim cfg_file_name out_file_name > log_file_name
#
#    (3) Set up the next loop, If a multiple run is enabled (OPT_LOOP=1).
#        Change the parameter index for looping and go to step (1);
#        otherwise, escape the loop and finish this part.
# 
# If OPT_POSTPROC is disabled (OPT_POSTPROC=0), this part is bypassed.
# Note that you can run postproc_netsim separately if you bypass this part.

if [ ${OPT_POSTPROC} -eq 1 ];then
   TIME_START_POSTPROC=`date +"%X, %F";`;
   echo "";
   echo "   Start of the postprocessing: ${TIME_START_POSTPROC}";   
   #####################################
   # Step 1 Setup to postprocess       #
   #####################################
   # If OPT_LOOP is turned on, make a loop; otherwise, "break" the loop for a single run.   
   if [ $OPT_LOOP -eq 1 ];then
      LOOPING_INDX=$CFG_USER_PER_SECTOR_FROM;
   else
      LOOPING_INDX=0;
   fi

   while [ $LOOPING_INDX -le $CFG_USER_PER_SECTOR_TO ];do
   
      #####################################
      # Step 1.ii Set up an individual dir#
      #####################################
      if [ $OPT_LOOP -eq 0 ];then   
         LOOPING_INDX="_single_run";
      fi
      SCN_NAME=${OPT_SCENARIO}${LOOPING_INDX};
      
##################################################################################
      if [ ${OPT_MC_SIMULS} -eq 1 ];then
##################################################################################

         CNTR_MC=${CNTR_MC_MAX};
	 
	 while [ ${CNTR_MC} -gt 0 ];do

            DIR_2RUN=$DIR_ROOT"/"$DIR_RESULTS"/"${SCN_NAME}"/"${CNTR_MC};	 
            FILE_POSTPROC_INPUT=${SCN_NAME}'.nout';      
            FILE_POSTPROC_OUT=${SCN_NAME}'.pout'; # output file for postprocessing
            FILE_POSTPROC_LOG=${SCN_NAME}'.plog'; # Log file for postprocessing

            #####################################
            # Step 1.iii Copy the template file #
            #####################################	
	    echo "";
            echo "      Copying template files for ${SCN_NAME}/${CNTR_MC}";
	    
            cd $DIR_ROOT"/"$DIR_TEMPLATES; 
            cp ${FILE_POSTPROC_CFG} $DIR_2RUN;

            #####################################
            # Step 1.iv Change the template file#
            #####################################
	    echo "      cd $DIR_2RUN;";
            cd $DIR_2RUN;      
            change_template_string ${FILE_POSTPROC_CFG} "file_postproc_input" ${FILE_POSTPROC_INPUT};
      
            # Check if the input files to postproc_netsim is correctly changed in the template file.
            # Why the input file is hidden?
            # In order to match the syntax to run netsim and postproc_netsim.
            # postproc_netsim is developped later than netsim.
            cat ${FILE_POSTPROC_CFG} | egrep "file_postproc_input" | awk '{  printf("      The input file to postproc_netsim: %s\n", $3); }'

            #####################################
            # Step 2 Postproc data in this dir  #
            #####################################
            RUN_CMD="../../../bin/postproc_netsim ${FILE_POSTPROC_CFG} ${FILE_POSTPROC_OUT} > ${FILE_POSTPROC_LOG};";	    
#            RUN_CMD="postproc_netsim ${FILE_POSTPROC_CFG} ${FILE_POSTPROC_OUT} > ${FILE_POSTPROC_LOG};";	    	    
            echo "         ${RUN_CMD}";
      	       if [ ${OPT_DONT_RUN} -eq 1 ];then
	          echo "         *********** Dummy command: postproc_netsim is not executed! ***********";
	       else
                  eval ${RUN_CMD};
	       fi

	    let CNTR_MC=${CNTR_MC}-1;
	    
	 done

##################################################################################
      else
##################################################################################      
      
      DIR_2RUN=$DIR_ROOT"/"$DIR_RESULTS"/"${SCN_NAME};
      FILE_POSTPROC_INPUT=${SCN_NAME}'.nout';      
      FILE_POSTPROC_OUT=${SCN_NAME}'.pout'; # output file for postprocessing
      FILE_POSTPROC_LOG=${SCN_NAME}'.plog'; # Log file for postprocessing

      #####################################
      # Step 1.iii Copy the template file #
      #####################################	
      echo "";
      echo "      Copying template files for ${SCN_NAME}";
      
      cd $DIR_ROOT"/"$DIR_TEMPLATES; 
      cp ${FILE_POSTPROC_CFG} $DIR_2RUN;

      #####################################
      # Step 1.iv Change the template file#
      #####################################
      echo "      cd $DIR_2RUN;";      
      cd $DIR_2RUN;      
      change_template_string ${FILE_POSTPROC_CFG} "file_postproc_input" ${FILE_POSTPROC_INPUT};
      
      # Check if the input files to postproc_netsim is correctly changed in the template file.
      # Why the input file is hidden?
      # In order to match the syntax to run netsim and postproc_netsim.
      # postproc_netsim is developped later than netsim.
      echo "";
      cat ${FILE_POSTPROC_CFG} | egrep "file_postproc_input" | awk '{  printf("      The input file to postproc_netsim: %s\n", $3); }'

      #####################################
      # Step 2 Postproc data in this dir  #
      #####################################
      echo "         postproc_netsim ${FILE_POSTPROC_CFG} ${FILE_POSTPROC_OUT} > ${FILE_POSTPROC_LOG};"
      postproc_netsim ${FILE_POSTPROC_CFG} ${FILE_POSTPROC_OUT} > ${FILE_POSTPROC_LOG};
      RUN_CMD="../../bin/postproc_netsim ${FILE_POSTPROC_CFG} ${FILE_POSTPROC_OUT} > ${FILE_POSTPROC_LOG};";
	 if [ ${OPT_DONT_RUN} -eq 1 ];then
	    echo "         *********** Dummy command: postproc_netsim is not executed! ***********";
	 else
            eval ${RUN_CMD};
	 fi
	 
##################################################################################      
      fi
##################################################################################
	 
# Comment this part out because sending two mails for a short simulation run is bugging.
#
#      MAIL_MESSAGE="${MAIL_MESSAGE}   ${RUN_CMD}";
#      echo "      postproc_netsim ${FILE_POSTPROC_CFG} ${FILE_POSTPROC_OUT};"
#      postproc_netsim ${FILE_POSTPROC_CFG} ${FILE_POSTPROC_OUT};
#
# Comment this part out because sending two mails for a short simulation run is bugging.

      #####################################
      # Step 3 Set up the next loop       #
      #####################################
      if [ $OPT_LOOP -eq 0 ];then # Breaking out of the loop for a single run
         break;      
      fi
      # Increment the user index by CFG_USER_PER_SECTOR_INCR.
      let LOOPING_INDX=LOOPING_INDX+$CFG_USER_PER_SECTOR_INCR;
   done

   echo "";
   echo "      ----------------------------------------------------";
   echo "      Run matlab separately to get the performance graph.";
   echo "      ----------------------------------------------------";   
   # Show the commands and changes to make.   
fi

##################################################################################
#                       Collect the post-processed results                       #
##################################################################################
if [ ${OPT_PP_COLLECT} -eq 1 ];then
   # This part should be done when the post-processed data is collected.
   # If not, there is no point of creating this directory.   
   #####################################
   # Step 1.i Set up directories       #
   ##################################### 
   # The postprocessed results are stored separately from the raw simulation results.
   # In other words, the postprocessed results should be stored in directory "postproc_results".
   # The way how the results are managed is to created a sub-directory under postproc_results
   #  and dump everything into this sub-directory.
   # The convention used here is the name of the scenario option ${OPT_SCENARIO} followed by
   #  the processed time (year, month, and date: date +"%Y%m%d").
   # A dash is placed between the scenario option name and the processed time.
   # For example, postproc_results/full_buffer_u-20071120 is a group of processed data for:
   #    full buffer traffics with variation of the users per sector (full_buffer_u),
   #    the processing begins on Nov. 20, 2007 (20071120).
   
   # e.g. DIR_POSTPROC_RESULTS=${DIR_ROOT}/postproc_results/full_buffer_u-20071120   
   DIR_POSTPROC_RESULTS=${DIR_ROOT}'/'${DIR_POSTPROC}'/'${OPT_SCENARIO}'-'`date +"%Y%m%d"`;
   # If the directory already exist, ask if overwrite; Otherwise, create the directory.
   if test ! -d ${DIR_POSTPROC_RESULTS}; then
         RUN_CMD="mkdir ${DIR_POSTPROC_RESULTS};";
	 echo "       mkdir ${DIR_POSTPROC_RESULTS};";
         mkdir ${DIR_POSTPROC_RESULTS};
   else
      echo "      Directory ${DIR_POSTPROC_RESULTS} already exists."
      echo "         Select one of the following options:"
      echo "            \"a\" to abort,"
      echo "            \"o\" to overwrite,"
      echo "            \"an integer\" to give an indexing number."            
      echo "                For example, an indexing number of \"1\" creates a directory"
      echo "                with a suffix of ${DIR_POSTPROC_RESULTS}-1."
      read;
      if [ ${REPLY} == "a" -o  ${REPLY} == "A" ];then
         echo "      Abort...";
         exit 1;
      elif [ ${REPLY} == "o" -o  ${REPLY} == "O" ];then
         echo "      Overwriting to ${DIR_POSTPROC_RESULTS}...";
      else
         DIR_POSTPROC_RESULTS=${DIR_POSTPROC_RESULTS}'-'${REPLY};
	 echo "       mkdir ${DIR_POSTPROC_RESULTS};";
         mkdir ${DIR_POSTPROC_RESULTS};
      fi
   fi
      
##################################################################################            
   if [ $OPT_LOOP -eq 1 ];then
      LOOPING_INDX=$CFG_USER_PER_SECTOR_FROM;
   else
      LOOPING_INDX=0;
   fi

   while [ $LOOPING_INDX -le $CFG_USER_PER_SECTOR_TO ];do
      #####################################
      # Step 1.ii Set up an individual dir#
      #####################################
      if [ $OPT_LOOP -eq 0 ];then   
         LOOPING_INDX="_single_run";
      fi
      SCN_NAME=${OPT_SCENARIO}${LOOPING_INDX};

      # Currently, tested ONLY for MC simuls.
##################################################################################      
      if [ ${OPT_MC_SIMULS} -eq 1 ];then
##################################################################################      
         CNTR_MC=${CNTR_MC_MAX};
         while [ ${CNTR_MC} -gt 0 ];do
            DIR_2RUN=$DIR_ROOT"/"$DIR_RESULTS"/"${SCN_NAME}"/"${CNTR_MC};	 
   	    echo "      cd $DIR_2RUN;";
            cd $DIR_2RUN;      
	    
	    if [ $OPT_TRAFFIC_TYPE  == "full_buffer" ];then
               FILES_2COLLECT=$SCN_NAME'.Tput_Bytes_per_sec';      
	    fi

            #####################################
            # Step 2 Postproc data in this dir  #
            #####################################
            RUN_CMD="cp ${FILES_2COLLECT} ${DIR_POSTPROC_RESULTS}/${FILES_2COLLECT}.${CNTR_MC}";
            echo "         ${RUN_CMD}";
   	    if [ ${OPT_DONT_RUN} -eq 1 ];then
	       echo "         *********** Dummy command: cp is not executed! ***********";
	    else
               eval ${RUN_CMD};
	    fi

	    let CNTR_MC=${CNTR_MC}-1;
	 done
##################################################################################
      else
##################################################################################	 
         DIR_2RUN=$DIR_ROOT"/"$DIR_RESULTS"/"${SCN_NAME};
   	 echo "      cd $DIR_2RUN;";
         cd $DIR_2RUN;      
	    
	 if [ $OPT_TRAFFIC_TYPE  == "full_buffer" ];then
            FILES_2COLLECT=$SCN_NAME'.Tput_Bytes_per_sec';      
	 elif [ $OPT_TRAFFIC_TYPE  == "avbr" ];then
            FILES_2COLLECT=$SCN_NAME'.Tput_Bytes_per_sec';      
         fi
         #####################################
         # Step 2 Postproc data in this dir  #
         #####################################
         RUN_CMD="cp ${FILES_2COLLECT} ${DIR_POSTPROC_RESULTS}";
         echo "         ${RUN_CMD}";
   	 if [ ${OPT_DONT_RUN} -eq 1 ];then
	    echo "         *********** Dummy command: cp is not executed! ***********";
	 else
            eval ${RUN_CMD};
	 fi
##################################################################################	 
      fi
##################################################################################      
      #####################################
      # Step 3 Set up the next loop       #
      #####################################
      if [ $OPT_LOOP -eq 0 ];then # Breaking out of the loop for a single run
         break;      
      fi
      # Increment the user index by CFG_USER_PER_SECTOR_INCR.
      let LOOPING_INDX=LOOPING_INDX+$CFG_USER_PER_SECTOR_INCR;
   done
   
   if [ ${OPT_MC_SIMULS} -eq 1 ];then   
      #####################################
      # Collect the postprocessed results #
      #####################################
      echo "";
      echo "      cd ${DIR_POSTPROC_RESULTS};";
      cd ${DIR_POSTPROC_RESULTS};
      RUN_CMD="collect_postproc_results";
      echo "         ${RUN_CMD}";
      if [ ${OPT_DONT_RUN} -eq 1 ];then
         echo "         *********** Dummy command: collect_postproc_results is not executed! ***********";
      else
         eval ${RUN_CMD};
      fi
   else
      #####################################
      #   Sort the postprocessed results  #
      #####################################
      echo "";
      echo "      cd ${DIR_POSTPROC_RESULTS};";
      cd ${DIR_POSTPROC_RESULTS};
      for tmp_filename in `ls`;do
         RUN_CMD_1="sort -n -k2 ${tmp_filename} > ${tmp_filename}.tmp";
         RUN_CMD_2="mv ${tmp_filename}.tmp ${tmp_filename}";	 
         echo "         ${RUN_CMD_1}";
         echo "         ${RUN_CMD_2}";	 
         if [ ${OPT_DONT_RUN} -eq 1 ];then
            echo "         *********** Dummy command: sort is not executed! ***********";
         else
            eval ${RUN_CMD_1};
            eval ${RUN_CMD_2};	    
         fi
      done
      # Convert the format because the files should be plotted on Windows with Matlab.
      unix2dos *;
   fi   
fi
##################################################################################            

##################################################################################
#                       mail the status report to the user                       #
##################################################################################
MAIL_MESSAGE="${MAIL_MESSAGE}
TIME_START_SIMUL=${TIME_START_SIMUL}         
TIME_END_SIMUL=${TIME_END_SIMUL}             
TIME_START_POSTPROC=${TIME_START_POSTPROC}   
TIME_END_POSTPROC=${TIME_END_POSTPROC}";
MAIL_TITLE="Netsim. Job done";
if [ ${OPT_EMAIL} -eq 1 ];then
   echo -e "   Sending an email notice to ${MAIL_RECIPIENTS}...";
   echo ${MAIL_MESSAGE} | mail -s "${MAIL_TITLE}" ${MAIL_RECIPIENTS};
fi
##################################################################################
TIME_EOF=`date +"%X, %F";`;
echo -e "\033[36mEOF: main_netsim, ${TIME_EOF}\033[0m";
exit 0;
